import { useState, useEffect } from 'react';
import { WorkflowDefinition } from '@/components/workflows/WorkflowExecutor';
import { WorkflowConfig } from '@/components/artifacts/workflows/config/WorkflowConfig';
import { getTemplateGroup } from '@/components/artifacts/workflows/config/templateGroups';

/**
 * CSM Dashboard Workflow Hook
 *
 * Manages workflow launching logic including:
 * - URL parameter parsing for template groups/templates
 * - Dynamic workflow generation for factory-based workflows
 * - Modal state and navigation
 * - Task launching logic
 */

interface UseDashboardWorkflowsProps {
  configMap: Record<string, WorkflowConfig>;
  staticWorkflowDefinitionsMap: Record<string, WorkflowDefinition>;
  workflowFactories: Record<string, (customerId: string) => Promise<WorkflowDefinition>>;
  upcomingTasks: Array<{
    id: number;
    customer: string;
    configId?: string;
  }>;
}

interface UseDashboardWorkflowsReturn {
  // State
  launchingTask: number | null;
  showTaskModal: boolean;
  modalConfig: { type: 'group' | 'template'; id: string; groupIndex?: number } | null;
  defaultLaunchConfig: { type: 'group' | 'template'; id: string } | null;
  loadingWorkflow: boolean;
  workflowError: string | null;

  // Derived values
  currentConfigId: string | undefined;
  currentConfig: WorkflowConfig | null;
  currentWorkflowDefinition: WorkflowDefinition | null;

  // Handlers
  handleLaunchTaskMode: (taskId?: number) => void;
  handleCloseModal: () => void;
  handleNextCustomer: () => void;
}

export function useDashboardWorkflows({
  configMap,
  staticWorkflowDefinitionsMap,
  workflowFactories,
  upcomingTasks
}: UseDashboardWorkflowsProps): UseDashboardWorkflowsReturn {
  // State
  const [launchingTask, setLaunchingTask] = useState<number | null>(null);
  const [showTaskModal, setShowTaskModal] = useState(false);
  const [modalConfig, setModalConfig] = useState<{
    type: 'group' | 'template';
    id: string;
    groupIndex?: number;
  } | null>(null);
  const [defaultLaunchConfig, setDefaultLaunchConfig] = useState<{
    type: 'group' | 'template';
    id: string;
  } | null>(null);

  // State for dynamically generated workflow definitions
  const [generatedWorkflows, setGeneratedWorkflows] = useState<Record<string, WorkflowDefinition>>({});
  const [loadingWorkflow, setLoadingWorkflow] = useState(false);
  const [workflowError, setWorkflowError] = useState<string | null>(null);

  // Parse URL parameters on component mount
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const urlParams = new URLSearchParams(window.location.search);
    const templateGroupId = urlParams.get('templateGroupId') || urlParams.get('templateGroup');
    const templateId = urlParams.get('templateId');
    const template = urlParams.get('template');

    // Check sessionStorage as fallback
    let sessionParams = null;
    try {
      const storedParams = sessionStorage.getItem('auth_redirect_params');
      if (storedParams) {
        sessionParams = JSON.parse(storedParams);
      }
    } catch (error) {
      console.error("Error reading sessionStorage:", error);
    }

    // Use URL parameters first, then fall back to sessionStorage
    const finalTemplateGroupId = templateGroupId || sessionParams?.templateGroup || sessionParams?.templateGroupId;
    const finalTemplateId = templateId || sessionParams?.templateId;
    const finalTemplate = template || sessionParams?.template;

    if (finalTemplateGroupId) {
      setDefaultLaunchConfig({ type: 'group', id: finalTemplateGroupId });

      // Clear sessionStorage after successful use
      if (sessionParams) {
        sessionStorage.removeItem('auth_redirect_params');
      }
    } else if (finalTemplateId) {
      setDefaultLaunchConfig({ type: 'template', id: finalTemplateId });

      // Clear sessionStorage after successful use
      if (sessionParams) {
        sessionStorage.removeItem('auth_redirect_params');
      }
    } else if (finalTemplate) {
      setDefaultLaunchConfig({ type: 'template', id: finalTemplate });

      // Clear sessionStorage after successful use
      if (sessionParams) {
        sessionStorage.removeItem('auth_redirect_params');
      }
    }
  }, []);

  // Generate workflow definition when modal config changes (for factory-based workflows)
  useEffect(() => {
    const configId = modalConfig?.id;
    if (!configId || !showTaskModal) return;

    // Check if this workflow needs to be generated by a factory
    const factory = workflowFactories[configId];
    if (!factory) return;

    // Check if we already have this workflow generated
    if (generatedWorkflows[configId]) return;

    // Generate the workflow
    const generateWorkflow = async () => {
      setLoadingWorkflow(true);
      setWorkflowError(null);
      try {
        const customerId = '550e8400-e29b-41d4-a716-446655440001'; // Obsidian Black
        const workflow = await factory(customerId);
        setGeneratedWorkflows(prev => ({
          ...prev,
          [configId]: workflow
        }));
      } catch (error) {
        console.error('Error generating workflow:', error);
        setWorkflowError(error instanceof Error ? error.message : 'Failed to generate workflow');
      } finally {
        setLoadingWorkflow(false);
      }
    };

    generateWorkflow();
  }, [modalConfig, showTaskModal, generatedWorkflows, workflowFactories]);

  // Handle escape key to close modal
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && showTaskModal) {
        handleCloseModal();
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [showTaskModal]); // eslint-disable-line react-hooks/exhaustive-deps

  // Handlers
  const handleLaunchTaskMode = (taskId?: number) => {
    setLaunchingTask(taskId || 0);

    // Always determine and set the config for this launch
    let configToUse: { type: 'group' | 'template'; id: string; groupIndex?: number };

    if (taskId) {
      // Launch specific task - check for task-specific overrides first
      const task = upcomingTasks.find(t => t.id === taskId);

      // First check if task has a specific configId
      if (task && (task as any).configId) {
        configToUse = {
          type: 'template',
          id: (task as any).configId
        };
      }
      else if (defaultLaunchConfig?.type === 'group') {
        configToUse = {
          type: 'group',
          id: defaultLaunchConfig.id,
          groupIndex: 0
        };
      }
      else if (defaultLaunchConfig?.type === 'template') {
        configToUse = {
          type: 'template',
          id: defaultLaunchConfig.id
        };
      }
      else if (task) {
        let groupId = 'healthcare-demo';
        if (task.customer.includes('Acme') || task.customer.includes('Intrasoft')) {
          groupId = 'enterprise-demo';
        }
        configToUse = { type: 'group', id: groupId, groupIndex: 0 };
      }
      else {
        configToUse = { type: 'group', id: 'healthcare-demo', groupIndex: 0 };
      }
    } else {
      // Launch general task mode (no specific task)
      if (defaultLaunchConfig?.type === 'group') {
        configToUse = {
          type: 'group',
          id: defaultLaunchConfig.id,
          groupIndex: 0
        };
      }
      else if (defaultLaunchConfig?.type === 'template') {
        configToUse = {
          type: 'template',
          id: defaultLaunchConfig.id
        };
      }
      else {
        configToUse = { type: 'template', id: 'obsblk-strategic-planning' };
      }
    }

    setModalConfig(configToUse);

    // Just show the modal
    setShowTaskModal(true);
    setTimeout(() => setLaunchingTask(null), 500);
  };

  const handleCloseModal = () => {
    setShowTaskModal(false);
    // Keep modalConfig to preserve component state - don't set to null
  };

  const handleNextCustomer = () => {
    if (modalConfig?.type === 'group') {
      const group = getTemplateGroup(modalConfig.id);
      const currentIndex = modalConfig.groupIndex || 0;

      if (group && currentIndex < group.templates.length - 1) {
        // Move to next template in the group
        setModalConfig({
          ...modalConfig,
          groupIndex: currentIndex + 1
        });
      } else {
        // At the end of the group, close modal
        handleCloseModal();
      }
    } else {
      // Not in a group, just close
      handleCloseModal();
    }
  };

  // Derived values
  const getCurrentConfigId = () => modalConfig?.id || defaultLaunchConfig?.id;
  const currentConfigId = getCurrentConfigId();
  const currentConfig = currentConfigId ? configMap[currentConfigId] : null;

  // Check for workflow definition in order: generated > static > null
  const currentWorkflowDefinition = currentConfigId
    ? (generatedWorkflows[currentConfigId] || staticWorkflowDefinitionsMap[currentConfigId])
    : null;

  return {
    // State
    launchingTask,
    showTaskModal,
    modalConfig,
    defaultLaunchConfig,
    loadingWorkflow,
    workflowError,

    // Derived values
    currentConfigId,
    currentConfig,
    currentWorkflowDefinition,

    // Handlers
    handleLaunchTaskMode,
    handleCloseModal,
    handleNextCustomer
  };
}
