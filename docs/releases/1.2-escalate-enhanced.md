# Release 1.2: Escalate Enhanced

**Version:** 1.2
**Status:** Planning
**Timeline:** Jan 6 - Jan 17, 2026
**Total Effort:** 30 hours
**Tagline:** "Get help when you need it"
**Milestone:** **Flow Control Complete** ðŸŽ¯

---

## Overview

Release 1.2 extends the basic Escalate functionality to support the same sophisticated trigger system as Snooze (1.0) and Skip (1.1). This **completes the Flow Control arc** - all three actions (Snooze, Skip, Escalate) now support the unified trigger framework with complete architectural parity.

**Milestone Context:** This is the final release in the Flow Control arc (1.0-1.2). With 1.2 shipped, all three workflow interrupt actions support date triggers, event triggers, AND/OR logic, and sophisticated condition-based workflows.

**Architecture:** Mirrors Phase 1.0 (Snooze) and 1.1 (Skip) exactly - same JSONB trigger arrays, same event types, same evaluation patterns.

---

## Trigger Framework (Inherited from Phase 1.0)

### Unified Trigger Model

All triggers follow this structure:

```typescript
interface EscalateTrigger {
  id: string;                    // Unique ID: "trigger-[type]-[timestamp]"
  type: 'date' | 'event';        // Trigger type
  config: DateTriggerConfig | EventTriggerConfig;
  createdAt: string;             // ISO 8601 timestamp
}
```

### Date Triggers

```typescript
interface DateTriggerConfig {
  date: string;      // ISO 8601: "2026-01-15T09:00:00Z"
  timezone?: string; // IANA timezone: "America/New_York" (optional, defaults to UTC)
}
```

**Example:**
```json
{
  "id": "trigger-date-1700000000",
  "type": "date",
  "config": {
    "date": "2026-01-15T09:00:00Z",
    "timezone": "America/New_York"
  },
  "createdAt": "2025-11-13T12:00:00Z"
}
```

### Event Triggers

```typescript
interface EventTriggerConfig {
  eventType: EventType;
  eventConfig?: Record<string, unknown>; // Event-specific configuration
}

type EventType =
  | 'workflow_action_completed'   // Another workflow completes
  | 'customer_login'              // Customer logs in
  | 'usage_threshold_crossed'     // Usage metric crosses threshold
  | 'manual_event';               // Manual trigger
```

**Example (Usage Threshold):**
```json
{
  "id": "trigger-event-1700000001",
  "type": "event",
  "config": {
    "eventType": "usage_threshold_crossed",
    "eventConfig": {
      "metricName": "arr",
      "threshold": 100000,
      "operator": ">="
    }
  },
  "createdAt": "2025-11-13T12:00:00Z"
}
```

### Combining Triggers

Workflows can have 1-3 triggers, combined with OR or AND logic:

```typescript
{
  escalate_triggers: EscalateTrigger[],     // 1-3 triggers
  escalate_trigger_logic: 'OR' | 'AND',     // How to combine (default: 'OR')
  escalate_to_user_id: UUID                 // Who receives the escalation
}
```

---

## The Four Trigger Conventions

### 1. DATE Only
**Implementation:** 1 date trigger, logic doesn't matter

```typescript
{
  escalate_triggers: [
    {
      id: "trigger-date-123",
      type: "date",
      config: { date: "2026-01-15T09:00:00Z" },
      createdAt: "2025-11-13T12:00:00Z"
    }
  ],
  escalate_trigger_logic: "OR",  // Default
  escalate_to_user_id: "user-vp-cs-uuid",
  escalate_reason: "Escalate to VP if not resolved by January 15th"
}
```

**Use Cases:**
- Time-based escalation deadlines
- SLA-driven escalations
- "Escalate if not resolved by X date"

---

### 2. EVENT Only
**Implementation:** 1 event trigger, logic doesn't matter

```typescript
{
  escalate_triggers: [
    {
      id: "trigger-event-456",
      type: "event",
      config: {
        eventType: "usage_threshold_crossed",
        eventConfig: {
          metricName: "arr",
          threshold: 100000,
          operator: ">="
        }
      },
      createdAt: "2025-11-13T12:00:00Z"
    }
  ],
  escalate_trigger_logic: "OR",
  escalate_to_user_id: "user-vp-cs-uuid",
  escalate_reason: "Escalate to VP when ARR exceeds $100k"
}
```

**Use Cases:**
- Value-based escalations ("big deals go to VPs")
- Risk-based escalations (health score drops)
- Complexity-based escalations

---

### 3. DATE and EVENT (Both Required - AND Logic)
**Implementation:** 2 triggers (1 date + 1 event), AND logic

```typescript
{
  escalate_triggers: [
    {
      id: "trigger-date-123",
      type: "date",
      config: { date: "2026-01-15T09:00:00Z" },
      createdAt: "2025-11-13T12:00:00Z"
    },
    {
      id: "trigger-event-456",
      type: "event",
      config: {
        eventType: "usage_threshold_crossed",
        eventConfig: {
          metricName: "arr",
          threshold: 100000,
          operator: ">="
        }
      },
      createdAt: "2025-11-13T12:00:00Z"
    }
  ],
  escalate_trigger_logic: "AND",  // BOTH must fire
  escalate_to_user_id: "user-vp-cs-uuid",
  escalate_reason: "Escalate on Jan 15th AND if ARR > $100k"
}
```

**Evaluation Logic:**
```
escalate = (current_date >= 2026-01-15) AND (arr >= 100000)
```

**Use Cases:**
- Time-gated high-value escalations
- "Only escalate big deals after X date"
- Compound conditions (both timing and business value)

---

### 4. DATE or EVENT (Whichever First - OR Logic)
**Implementation:** 2 triggers (1 date + 1 event), OR logic

```typescript
{
  escalate_triggers: [
    {
      id: "trigger-date-123",
      type: "date",
      config: { date: "2026-01-15T09:00:00Z" },
      createdAt: "2025-11-13T12:00:00Z"
    },
    {
      id: "trigger-event-456",
      type: "event",
      config: {
        eventType: "usage_threshold_crossed",
        eventConfig: {
          metricName: "health_score",
          threshold: 30,
          operator: "<="
        }
      },
      createdAt: "2025-11-13T12:00:00Z"
    }
  ],
  escalate_trigger_logic: "OR",  // EITHER can fire
  escalate_to_user_id: "user-manager-uuid",
  escalate_reason: "Escalate on Jan 15th OR if health score drops below 30"
}
```

**Evaluation Logic:**
```
escalate = (current_date >= 2026-01-15) OR (health_score <= 30)
```

**Use Cases:**
- Time-capped escalations with early warning
- "Escalate by Friday OR immediately if things go bad"
- Defensive escalation policies

---

## Features

### Feature 1: Escalate - All Trigger Conventions
**Effort:** 18 hours
**Priority:** 1 (Highest)

#### Database Schema

**Extend `workflow_executions` table:**

```sql
-- Add escalate trigger fields (mirrors snooze and skip fields)
ALTER TABLE workflow_executions
ADD COLUMN escalate_triggers JSONB DEFAULT '[]'::jsonb,
ADD COLUMN escalate_trigger_logic TEXT DEFAULT 'OR' CHECK (escalate_trigger_logic IN ('OR', 'AND')),
ADD COLUMN escalate_last_evaluated_at TIMESTAMPTZ,
ADD COLUMN escalate_trigger_fired_at TIMESTAMPTZ,
ADD COLUMN escalate_fired_trigger_type TEXT,
ADD COLUMN escalate_to_user_id UUID REFERENCES profiles(id);  -- Who receives escalation

-- GIN index for JSONB queries
CREATE INDEX idx_workflow_executions_escalate_triggers
  ON workflow_executions USING GIN (escalate_triggers);

-- Composite index for cron job
CREATE INDEX idx_workflow_executions_escalate_evaluation
  ON workflow_executions(status, escalate_last_evaluated_at)
  WHERE status = 'escalated';

-- Index for escalation recipient
CREATE INDEX idx_workflow_executions_escalate_to
  ON workflow_executions(escalate_to_user_id)
  WHERE escalate_to_user_id IS NOT NULL;
```

**Create history table:**

```sql
CREATE TABLE workflow_escalate_triggers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workflow_execution_id UUID REFERENCES workflow_executions(id) ON DELETE CASCADE,

  -- Trigger configuration
  trigger_type TEXT NOT NULL CHECK (trigger_type IN ('date', 'event')),
  trigger_config JSONB NOT NULL,

  -- Evaluation state
  is_fired BOOLEAN DEFAULT false,
  evaluated_at TIMESTAMPTZ,
  evaluation_count INTEGER DEFAULT 0,
  fired_at TIMESTAMPTZ,
  error_message TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_workflow_escalate_triggers_execution
  ON workflow_escalate_triggers(workflow_execution_id);

CREATE INDEX idx_workflow_escalate_triggers_fired
  ON workflow_escalate_triggers(is_fired, trigger_type);
```

**Helper function:**

```sql
CREATE FUNCTION get_escalated_workflows_for_evaluation(
  p_evaluation_interval_minutes INTEGER DEFAULT 5
) RETURNS TABLE (
  workflow_execution_id UUID,
  escalate_triggers JSONB,
  escalate_last_evaluated_at TIMESTAMPTZ,
  customer_id UUID,
  user_id UUID,
  escalate_to_user_id UUID
) LANGUAGE plpgsql AS $$
BEGIN
  RETURN QUERY
  SELECT
    we.id,
    we.escalate_triggers,
    we.escalate_last_evaluated_at,
    we.customer_id,
    we.assigned_csm_id,
    we.escalate_to_user_id
  FROM workflow_executions we
  WHERE we.status = 'escalated'
    AND we.escalate_triggers IS NOT NULL
    AND jsonb_array_length(we.escalate_triggers) > 0
    AND (
      we.escalate_last_evaluated_at IS NULL
      OR we.escalate_last_evaluated_at < NOW() - (p_evaluation_interval_minutes || ' minutes')::INTERVAL
    );
END;
$$;
```

#### API Endpoints

**POST /api/workflows/escalate-with-triggers**

Escalate a workflow with trigger configuration.

**Request:**
```typescript
{
  workflowId: string;
  triggers: EscalateTrigger[];     // 1-3 triggers
  logic?: 'OR' | 'AND';            // Default: 'OR'
  escalateToUserId: string;        // Required: who receives escalation
  reason?: string;                 // Optional escalation reason
}
```

**Response:**
```typescript
{
  success: true,
  message: "Workflow escalated with 2 trigger(s)",
  workflowId: string,
  triggerCount: number,
  escalatedTo: {
    userId: string,
    name: string
  },
  willEscalate: string             // Human-readable summary
}
```

**GET /api/workflows/escalated**

Get all escalated workflows.

**Query Params:**
- `userId` - Filter by assigned user OR escalated-to user
- `escalatedToMe` - Show only workflows escalated to the requesting user
- `includeTriggered` - Include workflows with fired triggers (default: false)

**Response:**
```typescript
{
  workflows: WorkflowExecutionWithEscalateTriggers[],
  count: number
}
```

**POST /api/workflows/de-escalate-now**

Manually de-escalate a workflow (return to original assignee).

**Request:**
```typescript
{
  workflowId: string;
  reason?: string;
}
```

**Response:**
```typescript
{
  success: true,
  message: "Workflow de-escalated successfully",
  workflowId: string,
  returnedTo: {
    userId: string,
    name: string
  }
}
```

#### Service Layer

**Create `EscalateTriggerEvaluator` service:**

Location: `src/lib/services/EscalateTriggerEvaluator.ts`

**Methods (mirror TriggerEvaluator and SkipTriggerEvaluator):**

```typescript
class EscalateTriggerEvaluator {
  // Main evaluation entry point
  static async evaluateTrigger(
    trigger: EscalateTrigger,
    workflowExecutionId: string,
    supabase: SupabaseClient
  ): Promise<TriggerEvaluationResult>

  // Date trigger evaluation
  static async evaluateDateTrigger(
    config: DateTriggerConfig,
    supabase: SupabaseClient
  ): Promise<boolean>

  // Event trigger evaluation
  static async evaluateEventTrigger(
    config: EventTriggerConfig,
    workflowExecutionId: string,
    supabase: SupabaseClient
  ): Promise<{ triggered: boolean; reason?: string }>

  // Batch evaluation for cron
  static async evaluateAllTriggers(
    workflowExecutionId: string,
    triggers: EscalateTrigger[],
    logic: 'OR' | 'AND',
    supabase: SupabaseClient
  ): Promise<{
    shouldExecuteEscalation: boolean;
    firedTrigger?: EscalateTrigger;
    evaluationResults: Array<{
      trigger: EscalateTrigger;
      result: TriggerEvaluationResult;
    }>;
  }>

  // Update workflow with results
  static async updateWorkflowWithEvaluationResults(
    workflowExecutionId: string,
    shouldExecuteEscalation: boolean,
    firedTrigger: EscalateTrigger | undefined,
    supabase: SupabaseClient
  ): Promise<void>

  // Log evaluation to history
  static async logTriggerEvaluation(
    workflowExecutionId: string,
    trigger: EscalateTrigger,
    result: TriggerEvaluationResult,
    supabase: SupabaseClient
  ): Promise<void>

  // Execute escalation (notify escalated user)
  static async executeEscalation(
    workflowExecutionId: string,
    escalateToUserId: string,
    firedTrigger: EscalateTrigger,
    supabase: SupabaseClient
  ): Promise<void>
}
```

**Create `WorkflowEscalateService` for batch processing:**

Location: `src/lib/services/WorkflowEscalateService.ts`

```typescript
class WorkflowEscalateService {
  async evaluateAllEscalatedWorkflows(): Promise<{
    evaluated: number;
    escalated: number;  // Escalations executed
    errors: number;
    errorDetails?: Array<{ workflowId: string; error: string }>;
  }>
}
```

#### Cron Job

**Location:** `supabase/functions/daily-escalate-evaluation/`

**Schedule:** Daily at 8:10 AM UTC (5 minutes after skip evaluation)

**Flow:**
1. Fetch escalated workflows via `get_escalated_workflows_for_evaluation()`
2. Process in batches of 100 (parallel with `Promise.allSettled`)
3. Evaluate triggers via `EscalateTriggerEvaluator.evaluateAllTriggers()`
4. If triggers fire, execute escalation (notify escalated-to user)
5. Log all evaluations to `workflow_escalate_triggers` table
6. Return statistics

#### UI Components

**EnhancedEscalateModal**

Location: `src/components/workflows/EnhancedEscalateModal.tsx`

**Structure (clone of EnhancedSnoozeModal/EnhancedSkipModal):**
```tsx
<EnhancedEscalateModal
  workflowId={string}
  isOpen={boolean}
  onClose={() => void}
  onEscalate={(
    triggers: EscalateTrigger[],
    escalateToUserId: string,
    logic?: 'OR' | 'AND'
  ) => Promise<void>}
>
  <UserSelector
    label="Escalate to"
    placeholder="Select user or team"
    value={escalateToUserId}
    onChange={setEscalateToUserId}
  />

  <ModeSelector>
    <Radio value="immediate">Immediate</Radio>
    <Radio value="date-only">Date Only</Radio>
    <Radio value="event-only">Event Only</Radio>
    <Radio value="date-and-events">Date and/or Events</Radio>
  </ModeSelector>

  {mode === 'date-only' || mode === 'date-and-events' ? (
    <>
      <QuickDateOptions />
      <DateTimePicker />
    </>
  ) : null}

  {mode === 'event-only' || mode === 'date-and-events' ? (
    <EscalateTriggerBuilder
      triggers={eventTriggers}
      onChange={setEventTriggers}
      maxTriggers={mode === 'date-and-events' ? 2 : 3}
    />
  ) : null}

  {mode === 'date-and-events' && triggers.length > 1 ? (
    <TriggerLogicToggle value={logic} onChange={setLogic} />
  ) : null}

  <TextArea label="Why are you escalating?" />

  {mode !== 'immediate' ? (
    <PreviewBanner>
      Will escalate: {getEscalationSummary(triggers, logic)}
    </PreviewBanner>
  ) : null}

  <Button onClick={handleEscalate}>
    {mode === 'immediate' ? 'Escalate Now' : 'Schedule Escalation'}
  </Button>
</EnhancedEscalateModal>
```

**EscalateTriggerBuilder**

Location: `src/components/workflows/triggers/EscalateTriggerBuilder.tsx`

Reuses TriggerBuilder from Phase 1.0 with Escalate-specific labeling.

**EscalatedWorkflowCard**

Location: `src/components/workflows/EscalatedWorkflowCard.tsx`

**Features:**
- Display workflow details
- Show escalation recipient
- Show all escalate triggers with status
- Escalation time estimate (if conditional)
- Actions: View Details, De-escalate, Take Ownership

#### Success Criteria

- [ ] Can escalate with DATE only (1 date trigger)
- [ ] Can escalate with EVENT only (1 event trigger)
- [ ] Can escalate with DATE and EVENT (2 triggers, AND logic)
- [ ] Can escalate with DATE or EVENT (2 triggers, OR logic)
- [ ] Escalations execute correctly when triggers fire
- [ ] Escalated user receives notification
- [ ] 90%+ accuracy in trigger evaluation
- [ ] Cron processes 1000+ escalated workflows in <10 seconds

---

### Feature 2: Escalation Routing Rules
**Effort:** 8 hours
**Priority:** 2

#### Database Schema

```sql
CREATE TABLE escalation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  company_id UUID REFERENCES companies(id) ON DELETE CASCADE,

  -- Rule identity
  name TEXT NOT NULL,
  description TEXT,
  priority INTEGER DEFAULT 0,  -- Higher priority rules evaluated first

  -- Trigger conditions
  conditions JSONB NOT NULL,   -- When to apply this rule
  -- Example: { "arr": { "operator": ">", "value": 100000 } }

  -- Escalation target
  escalate_to_user_id UUID REFERENCES profiles(id),
  escalate_to_team_id UUID,  -- Future: Team escalations

  -- State
  is_active BOOLEAN DEFAULT true,
  created_by UUID REFERENCES profiles(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_escalation_rules_company ON escalation_rules(company_id, is_active);
CREATE INDEX idx_escalation_rules_priority ON escalation_rules(priority DESC);
```

#### Rule Evaluation

```typescript
class EscalationRuleEngine {
  static async evaluateRulesForWorkflow(
    workflowExecutionId: string,
    supabase: SupabaseClient
  ): Promise<{
    matchedRule?: EscalationRule;
    escalateToUserId?: string;
  }>

  static async applyRule(
    workflowExecutionId: string,
    rule: EscalationRule,
    supabase: SupabaseClient
  ): Promise<void>
}
```

#### UI: Rule Management

```tsx
<EscalationRulesManager>
  <RulesList>
    {rules.map(rule => (
      <RuleCard key={rule.id}>
        <RuleName>{rule.name}</RuleName>
        <RuleConditions>{formatConditions(rule.conditions)}</RuleConditions>
        <RuleTarget>â†’ {rule.escalateToUser.name}</RuleTarget>
        <Actions>
          <Button onClick={() => editRule(rule)}>Edit</Button>
          <Button onClick={() => toggleRule(rule)}>
            {rule.isActive ? 'Disable' : 'Enable'}
          </Button>
        </Actions>
      </RuleCard>
    ))}
  </RulesList>

  <Button onClick={openCreateRuleModal}>Create Rule</Button>
</EscalationRulesManager>
```

**Example Rules:**
- "Escalate to VP if ARR > $100k"
- "Escalate to Solutions team if health score < 30"
- "Escalate to manager if overdue by 7+ days"

#### Success Criteria

- [ ] Admin can create escalation rules
- [ ] Rules apply automatically based on workflow properties
- [ ] Can override automatic escalation manually
- [ ] Multiple rules can exist with priority ordering
- [ ] Rule history is logged

---

### Feature 3: Escalation Analytics
**Effort:** 4 hours
**Priority:** 3

#### Analytics View

```sql
CREATE VIEW escalation_analytics AS
SELECT
  workflow_definition_id,
  wd.name as workflow_name,
  escalate_to_user_id,
  p.full_name as escalated_to_name,
  COUNT(*) as escalation_count,
  EXTRACT(DOW FROM escalated_at) as day_of_week,
  jsonb_array_length(escalate_triggers) as trigger_count,
  escalate_trigger_logic,
  AVG(EXTRACT(EPOCH FROM (
    COALESCE(escalate_trigger_fired_at, NOW()) - escalated_at
  )) / 3600) as avg_escalation_delay_hours
FROM workflow_executions we
JOIN workflow_definitions wd ON we.workflow_definition_id = wd.id
LEFT JOIN profiles p ON p.id = we.escalate_to_user_id
WHERE status = 'escalated' OR escalate_triggers IS NOT NULL
GROUP BY workflow_definition_id, wd.name, escalate_to_user_id, p.full_name,
         day_of_week, trigger_count, escalate_trigger_logic;
```

#### Dashboard Widget

```tsx
<EscalationAnalyticsWidget>
  <Stat label="Total Escalations" value={totalEscalations} />
  <Stat label="Avg Delay Before Escalation" value={`${avgHours}h`} />
  <Stat label="Most Escalated To" value={topRecipient} />

  <Chart
    title="Escalations by Recipient"
    type="bar"
    data={escalationsByUser}
  />

  <Chart
    title="Escalation Frequency by Workflow"
    type="bar"
    data={escalationsByWorkflow}
  />

  <Chart
    title="Trigger Type Distribution"
    type="pie"
    data={triggerTypeBreakdown}
  />

  <Table title="Recent Escalations" data={recentEscalations} />
</EscalationAnalyticsWidget>
```

#### Success Criteria

- [ ] Dashboard shows escalation frequency by user
- [ ] Can filter by date range, workflow type, recipient
- [ ] Exportable escalation history (CSV)
- [ ] Trigger type distribution visible
- [ ] Manager can see team escalation patterns

---

## Dependencies

### Prerequisites from Phase 1.0 & 1.1
- `TriggerEvaluator` service (reuse event evaluation logic)
- `SkipTriggerEvaluator` pattern
- Event type catalog (shared across Snooze/Skip/Escalate)
- Daily cron infrastructure
- Trigger UI components (TriggerBuilder, TriggerDisplay)

### Reusable from Phase 1.0 & 1.1
- Event type definitions (usage_threshold_crossed, workflow_action_completed, etc.)
- Date trigger evaluation logic
- Timezone handling utilities
- Notification templates
- Action logging patterns

---

## Event Types (Shared with Snooze & Skip)

All event types from Phase 1.0 are reused:

1. **workflow_action_completed** - Wait for another workflow to complete
2. **customer_login** - Wait for customer to log in
3. **usage_threshold_crossed** - Wait for metric threshold
4. **manual_event** - Wait for manual trigger

See `docs/technical/trigger-event-types.md` for full catalog.

---

## Testing Strategy

### Unit Tests
- [ ] Escalate trigger validation
- [ ] EscalateTriggerEvaluator - date triggers
- [ ] EscalateTriggerEvaluator - event triggers
- [ ] EscalateTriggerEvaluator - OR logic
- [ ] EscalateTriggerEvaluator - AND logic
- [ ] WorkflowEscalateService - batch processing
- [ ] EscalationRuleEngine - rule matching
- [ ] EscalationRuleEngine - priority ordering

### Integration Tests
- [ ] POST /api/workflows/escalate-with-triggers
- [ ] GET /api/workflows/escalated
- [ ] POST /api/workflows/de-escalate-now
- [ ] Cron evaluation of escalated workflows
- [ ] Notification dispatch to escalated user
- [ ] Rule engine integration

### E2E Tests
- [ ] Escalate with date trigger only
- [ ] Escalate with event trigger only
- [ ] Escalate with AND logic (2 triggers)
- [ ] Escalate with OR logic (2 triggers)
- [ ] Automatic escalation via rule
- [ ] De-escalate workflow

---

## Migration Plan

### Phase 1: Database
```sql
-- Add escalate trigger columns
ALTER TABLE workflow_executions
ADD COLUMN escalate_triggers JSONB DEFAULT '[]'::jsonb,
ADD COLUMN escalate_trigger_logic TEXT DEFAULT 'OR',
ADD COLUMN escalate_last_evaluated_at TIMESTAMPTZ,
ADD COLUMN escalate_trigger_fired_at TIMESTAMPTZ,
ADD COLUMN escalate_fired_trigger_type TEXT,
ADD COLUMN escalate_to_user_id UUID REFERENCES profiles(id);

-- Create history table
CREATE TABLE workflow_escalate_triggers (...);

-- Create escalation rules table
CREATE TABLE escalation_rules (...);

-- Create helper function
CREATE FUNCTION get_escalated_workflows_for_evaluation(...);

-- Backfill: Convert existing basic escalations to trigger format (immediate)
UPDATE workflow_executions
SET escalate_triggers = '[]'::jsonb,
    escalate_trigger_logic = 'OR'
WHERE status = 'escalated'
  AND escalate_triggers IS NULL;
```

### Phase 2: Services
- Create `EscalateTriggerEvaluator.ts`
- Create `WorkflowEscalateService.ts`
- Create `EscalationRuleEngine.ts`
- Add types to `src/types/escalate-triggers.ts`

### Phase 3: API
- Deploy `/escalate-with-triggers` endpoint
- Deploy `/escalated` endpoint
- Deploy `/de-escalate-now` endpoint
- Maintain backward compatibility with immediate escalation

### Phase 4: UI
- Deploy `EnhancedEscalateModal`
- Deploy `EscalateTriggerBuilder`
- Deploy `EscalationRulesManager`
- Feature flag: `escalate_enhanced` (enable for internal first)

### Phase 5: Cron
- Deploy escalate evaluation cron job
- Monitor performance (<10s for 1000 workflows)

---

## Risks & Mitigation

### Risk 1: Notification Overload
**Mitigation:**
- Batch notifications (daily digest option)
- User preferences for notification frequency
- Escalation threshold: Don't re-notify on every evaluation

### Risk 2: Circular Escalations
**Mitigation:**
- Track escalation history
- Prevent escalating back to original assignee
- Maximum escalation depth (2 levels)

### Risk 3: Confusion Between Escalate and Reassign
**Mitigation:**
- Clear UI labels: "Escalate" vs "Reassign"
- Escalate maintains original assignee
- Escalate implies urgency/help needed

---

## Success Metrics

### Adoption
- 40%+ of escalations use conditional triggers within 2 weeks
- 25%+ of companies create escalation rules

### Quality
- <1% false escalation rate
- <1% missed escalation rate
- 90%+ user satisfaction

### Performance
- Cron completes in <10 seconds for 1000 escalated workflows
- API response <200ms for escalate operations

---

## Documentation Updates

- [ ] Update docs/WORKFLOWS.md with escalate trigger architecture
- [ ] Add tutorial: docs/tutorials/escalate-advanced-triggers.md
- [ ] Update API docs with escalate endpoints
- [ ] Reference shared event types documentation
- [ ] Add escalation rules documentation

---

## Post-Release

### Week 1
- Monitor escalation analytics dashboard
- Gather feedback on escalation rules
- Identify common escalation patterns

### Week 2
- Refine rule engine based on feedback
- Consider team-based escalations

### Month 1
- Evaluate for Phase 1.3 (String-Tie)
- Prepare String-Tie prompts for escalations

---

## Reference Files (Phase 1.0 & 1.1 to Clone)

### Database
- `supabase/migrations/20251125000000_workflow_triggers_phase1.sql` (Snooze)
- Pattern for escalate: Replace "wake" with "escalate", "snooze" with "escalate"

### Services
- `src/lib/services/TriggerEvaluator.ts` â†’ `EscalateTriggerEvaluator.ts`
- `src/lib/services/SkipTriggerEvaluator.ts` â†’ Reference for patterns

### API
- `src/app/api/workflows/snooze-with-triggers/route.ts` â†’ `escalate-with-triggers/route.ts`
- `src/app/api/workflows/skipped/route.ts` â†’ `escalated/route.ts`

### Types
- `src/types/wake-triggers.ts` â†’ `escalate-triggers.ts`
- `src/types/skip-triggers.ts` â†’ Reference for patterns

### UI
- `src/components/workflows/EnhancedSnoozeModal.tsx` â†’ `EnhancedEscalateModal.tsx`
- `src/components/workflows/EnhancedSkipModal.tsx` â†’ Reference for patterns

---

## Milestone: Flow Control Complete ðŸŽ¯

With Release 1.2 shipped, the Flow Control arc is **complete**:

| Action | Triggers | Logic | UI | Cron | Analytics |
|--------|----------|-------|----|----|-----------|
| Snooze | âœ… | âœ… | âœ… | âœ… | âœ… |
| Skip | âœ… | âœ… | âœ… | âœ… | âœ… |
| Escalate | âœ… | âœ… | âœ… | âœ… | âœ… |

**Next:** Phase 1.3 (String-Tie) will add natural language interfaces for all three actions.

---

**Document Version:** 1.0
**Last Updated:** 2025-11-13
**Status:** Planning approved, architecture aligned
